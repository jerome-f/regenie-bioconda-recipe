diff --git a/CMakeLists.txt b/CMakeLists.txt
index b874c33..c871154 100755
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,13 +1,9 @@
-# For Intel MKL, set MKLROOT=<MKL_path> when running cmake
-#   e.g. MKLROOT=/opt/mkl/ cmake -S regenie_dir/ -B regenie_dir/build/
-# For OpenBLAS, set OPENBLAS_ROOT=<OpenBLAS_path> when running cmake
-#   note: it also requires lapacke library
-# For static compilation on Linux systems, set STATIC=1 when running cmake
-#   -> this excludes GLIBC
-
-
 cmake_minimum_required(VERSION 3.13)
 
+if(POLICY CMP0167)
+  cmake_policy(SET CMP0167 OLD)
+endif()
+
 # detect OS architecture
 execute_process(
   COMMAND uname -s
@@ -26,64 +22,23 @@ include(CMakePackageConfigHelpers)
 include(GNUInstallDirs)
 
 # specify the C++ standard
-set(CMAKE_CXX_STANDARD 11)
+set(CMAKE_CXX_STANDARD 14)
 set(CMAKE_CXX_STANDARD_REQUIRED ON)
 set(CMAKE_CXX_EXTENSIONS OFF)  # Ensures -std=c++11
 
 ######################################
 ######## check input variables
 
-# check BGEN_PATH
-if("$ENV{BGEN_PATH}" STREQUAL "")
-  message( FATAL_ERROR "Must specify path to BGEN library in 'BGEN_PATH'")
-else()
-  set(BGEN_PATH "$ENV{BGEN_PATH}" CACHE INTERNAL "Set BGEN library path")
-  if (NOT EXISTS ${BGEN_PATH})
-    message( FATAL_ERROR "Specified BGEN library directory '${BGEN_PATH}' does not exist")
-  endif()
-endif()
-
 # check for static compilation
-if($ENV{STATIC})
+if(BUILD_SHARED_LIBS)
+  set(BUILD_STATIC OFF CACHE INTERNAL "Dynamic compilation")
+  set(Boost_USE_STATIC_LIBS OFF)
+else()
   set(BUILD_STATIC ON CACHE INTERNAL "Static compilation")
+  set(Boost_USE_STATIC_LIBS ON)
   message( STATUS "Static compilation mode")
 endif()
 
-# check Boost IOStreams
-if($ENV{HAS_BOOST_IOSTREAM})
-  set(HAS_BOOST_IOSTREAM 1 CACHE INTERNAL "Add Boost IO")
-  set(RG_VERSION "${RG_VERSION}.gz" CACHE INTERNAL "Update version")
-else()
-  set(HAS_BOOST_IOSTREAM 0 CACHE INTERNAL "Skip Boost IO")
-endif()
-
-# check MKL
-if(NOT "$ENV{MKLROOT}" STREQUAL "")
-  set(MKLROOT "$ENV{MKLROOT}" CACHE INTERNAL "Set MKL library path")
-  if (NOT EXISTS ${MKLROOT})
-    message( FATAL_ERROR "Specified MKL library directory '${MKLROOT}' does not exist")
-  endif()
-  message( STATUS "Will compile with Intel MKL library")
-endif()
-
-# check HTSlib
-if(NOT "$ENV{HTSLIB_PATH}" STREQUAL "")
-  set(HTSLIB_PATH "$ENV{HTSLIB_PATH}" CACHE INTERNAL "Set HTSlib library path")
-  if (NOT EXISTS ${HTSLIB_PATH})
-    message( FATAL_ERROR "Specified HTSlib library directory '${HTSLIB_PATH}' does not exist")
-  endif()
-  message( STATUS "Will compile with HTSlib")
-endif()
-
-# check OpenBLAS
-if(NOT "$ENV{OPENBLAS_ROOT}" STREQUAL "")
-  set(OPENBLAS_ROOT "$ENV{OPENBLAS_ROOT}" CACHE INTERNAL "Set OpenBLAS library path")
-  if (NOT EXISTS ${OPENBLAS_ROOT})
-    message( FATAL_ERROR "Specified OpenBLAS library directory '${OPENBLAS_ROOT}' does not exist")
-  endif()
-  message( STATUS "Will compile with OpenBLAS library")
-endif()
-
 ######################################
 ######## set flags and required libraries
 
@@ -92,9 +47,10 @@ set(Boost_USE_STATIC_LIBS    ${BUILD_STATIC})
 set(Boost_USE_DEBUG_LIBS     OFF)
 set(Boost_USE_MULTITHREADED  ON)
 set(Boost_USE_STATIC_RUNTIME OFF)
+set(MKLROOT "${CMAKE_PREFIX_PATH}")
 
-# list each file specifically
-add_executable(regenie
+# list each file specifically 
+add_executable(regenie 
   ${CMAKE_SOURCE_DIR}/src/Data.cpp
   ${CMAKE_SOURCE_DIR}/src/Files.cpp
   ${CMAKE_SOURCE_DIR}/src/Geno.cpp
@@ -116,32 +72,54 @@ add_executable(regenie
   ${CMAKE_SOURCE_DIR}/src/cox_score.cpp
   ${CMAKE_SOURCE_DIR}/src/cox_firth.cpp
   )
-target_include_directories(regenie PRIVATE ${CMAKE_SOURCE_DIR}/src)
+target_include_directories(regenie PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/src ${CMAKE_PREFIX_PATH}/include)
 
-set(CMAKE_CXX_FLAGS "-O3 -Wall -pedantic -ffast-math -Wno-unused-local-typedefs -Wno-deprecated-declarations -Wno-long-long -Wno-c11-extensions -fPIC")
-add_definitions(-DVERSION_NUMBER="${RG_VERSION}")
+set(CMAKE_CXX_FLAGS "-O3 -Wall -pedantic -ffast-math -Wno-unused-local-typedefs -Wno-deprecated-declarations -Wno-long-long -fPIC")
 
+find_package(OpenMP REQUIRED)
+target_link_libraries(regenie OpenMP::OpenMP_CXX)
 if("${UNAME_S}" STREQUAL "Linux")
-  find_package(OpenMP REQUIRED)
-  target_link_libraries(regenie PRIVATE OpenMP::OpenMP_CXX)
   if(${BUILD_STATIC})
-    target_link_options(regenie BEFORE PRIVATE -static-libgcc PRIVATE -static-libstdc++)
+    target_link_options(regenie BEFORE -static-libgcc -static-libstdc++)
   endif()
 elseif("${UNAME_S}" STREQUAL "Darwin")
-    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -stdlib=libc++")
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -stdlib=libc++")
 endif()
 
-set(EXTERN_LIBS_PATH "${CMAKE_SOURCE_DIR}/external_libs")
-target_include_directories(regenie PRIVATE ${EXTERN_LIBS_PATH}/)
+set(EXTERN_LIBS_PATH "${CMAKE_CURRENT_SOURCE_DIR}/external_libs")
+target_include_directories(regenie PUBLIC ${EXTERN_LIBS_PATH}/)
+
+# for BGEN (choose static if present first)
+find_library(ZSTD_LIBRARY zstd REQUIRED)
+find_library(DB_LIBRARY 
+  NAMES libdb.a db 
+  REQUIRED
+  )
+find_library(SQLITE3_LIBRARY sqlite3 REQUIRED)
+find_package(Boost 
+  REQUIRED COMPONENTS system filesystem thread 
+  OPTIONAL_COMPONENTS iostreams
+  )
+find_library(BGEN_LIBRARY 
+  NAMES libbgen.a 
+  REQUIRED
+  )
+target_link_libraries(regenie ${ZSTD_LIBRARY} ${BGEN_LIBRARY} ${DB_LIBRARY} ${SQLITE3_LIBRARY} ${Boost_LIBRARIES})
+target_include_directories(regenie 
+  PUBLIC
+  $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
+  $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}/genfile>
+  $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}/db>
+  $<INSTALL_INTERFACE:${BOOST_INCLUDEDIR}>
+  )
+add_definitions(${Boost_DEFINITIONS})
 
-# BGEN library and its dependencies
-find_library(ZSTD_LIBRARY libzstd.a HINTS "${BGEN_PATH}/build/3rd_party/zstd-1.1.0" REQUIRED)
-find_library(DB_LIBRARY libdb.a HINTS "${BGEN_PATH}/build/db" REQUIRED)
-find_library(SQLITE3_LIBRARY libsqlite3.a HINTS "${BGEN_PATH}/build/3rd_party/sqlite3" REQUIRED)
-find_library(Boost_LIBRARY libboost.a HINTS "${BGEN_PATH}/build/3rd_party/boost_1_55_0" REQUIRED)
-find_library(BGEN_LIBRARY libbgen.a HINTS "${BGEN_PATH}/build" REQUIRED)
-target_link_libraries(regenie PRIVATE ${ZSTD_LIBRARY} ${BGEN_LIBRARY} ${DB_LIBRARY} ${SQLITE3_LIBRARY} ${Boost_LIBRARY})
-target_include_directories(regenie PRIVATE ${BGEN_PATH} ${BGEN_PATH}/genfile/include/ ${BGEN_PATH}/3rd_party/boost_1_55_0/ ${BGEN_PATH}/3rd_party/zstd-1.1.0/lib ${BGEN_PATH}/db/include/ ${BGEN_PATH}/3rd_party/sqlite3)
+# Boost IO
+if(Boost_iostreams_FOUND) 
+  add_definitions(-DHAS_BOOST_IOSTREAM)
+  set(RG_VERSION "${RG_VERSION}.gz" CACHE INTERNAL "Update version")
+  message( STATUS "Will compile with Boost Iostreams library")
+endif()
 
 # MVTNorm library
 set(MVTN_PATH "${EXTERN_LIBS_PATH}/mvtnorm")
@@ -150,7 +128,7 @@ add_custom_target(
    COMMAND make
    WORKING_DIRECTORY ${MVTN_PATH}
 )
-target_link_libraries(regenie PRIVATE ${MVTN_PATH}/libMvtnorm.a)
+target_link_libraries(regenie ${MVTN_PATH}/libMvtnorm.a)
 add_dependencies(regenie libMvtnorm)
 
 # QF library
@@ -160,7 +138,7 @@ add_custom_target(
    COMMAND make
    WORKING_DIRECTORY ${QF_PATH}
 )
-target_link_libraries(regenie PRIVATE ${QF_PATH}/qf.a)
+target_link_libraries(regenie ${QF_PATH}/qf.a)
 add_dependencies(regenie libqf)
 
 # Quadpack library
@@ -170,7 +148,7 @@ add_custom_target(
    COMMAND make
    WORKING_DIRECTORY ${QUAD_PATH}
 )
-target_link_libraries(regenie PRIVATE ${QUAD_PATH}/libquad.a)
+target_link_libraries(regenie ${QUAD_PATH}/libquad.a)
 add_dependencies(regenie libquad)
 
 # PGEN library
@@ -180,12 +158,12 @@ add_custom_target(
    COMMAND make
    WORKING_DIRECTORY ${PGEN_PATH}
 )
-target_link_libraries(regenie PRIVATE ${PGEN_PATH}/pgenlib.a)
-target_include_directories(regenie PRIVATE ${PGEN_PATH} ${PGEN_PATH}/simde/ ${PGEN_PATH}/include/)
+target_link_libraries(regenie ${PGEN_PATH}/pgenlib.a)
+target_include_directories(regenie PUBLIC ${PGEN_PATH} ${PGEN_PATH}/simde/ ${PGEN_PATH}/include/)
 add_dependencies(regenie pgenlib)
 
 # REMETA library
-if(EXISTS ${HTSLIB_PATH})
+if(DEFINED HTSLIB_PATH)
   set(REMETA_PATH "${EXTERN_LIBS_PATH}/remeta")
   add_custom_target(
      remeta
@@ -209,91 +187,70 @@ if(EXISTS ${HTSLIB_PATH})
 endif()
 
 # Intel MKL
-if(EXISTS ${MKLROOT})
+if(DEFINED MKLROOT) 
   add_definitions(-DWITH_MKL -DEIGEN_USE_BLAS -DEIGEN_USE_LAPACKE)
-  target_include_directories(regenie PRIVATE ${MKLROOT}/include/)
-  if(${BUILD_STATIC}) # specify static libs
-    find_library(MKL_LP64_LIB libmkl_intel_lp64.a 
-      HINTS "${MKLROOT}/lib/intel64"
-      "${MKLROOT}/lib" 
-      REQUIRED)
-    find_library(MKL_THREAD_LIB libmkl_gnu_thread.a 
-      HINTS "${MKLROOT}/lib/intel64"
-      "${MKLROOT}/lib" 
-      REQUIRED)
-    find_library(MKL_CORE_LIB libmkl_core.a 
-      HINTS "${MKLROOT}/lib/intel64"
-      "${MKLROOT}/lib" 
-      REQUIRED)
-    target_link_libraries(regenie PRIVATE "-Wl,--start-group" ${MKL_LP64_LIB} ${MKL_THREAD_LIB} ${MKL_CORE_LIB} "-Wl,--end-group" -lgomp)
-  else() # use dynamic libs
-    find_library(MKL_LP64_LIB mkl_intel_lp64 
-      PATHS "${MKLROOT}/lib/intel64"
-      "${MKLROOT}/lib" 
-      REQUIRED)
+  target_include_directories(regenie PUBLIC ${MKLROOT}/include/)
+  find_library(MKL_LP64_LIB mkl_intel_lp64 
+    HINTS "${MKLROOT}/lib/intel64" 
+    "${MKLROOT}/lib" 
+    REQUIRED
+    )
+  if("${UNAME_S}" STREQUAL "Linux")
     find_library(MKL_THREAD_LIB mkl_gnu_thread 
-      PATHS "${MKLROOT}/lib/intel64"
+      HINTS "${MKLROOT}/lib/intel64" 
       "${MKLROOT}/lib" 
-      REQUIRED)
-    find_library(MKL_CORE_LIB mkl_core 
-      PATHS "${MKLROOT}/lib/intel64"
+      REQUIRED
+      )
+  elseif("${UNAME_S}" STREQUAL "Darwin")
+    find_library(MKL_THREAD_LIB mkl_intel_thread 
+      HINTS "${MKLROOT}/lib/intel64" 
       "${MKLROOT}/lib" 
-      REQUIRED)
-    target_link_libraries(regenie PRIVATE "-Wl,--no-as-needed" ${MKL_LP64_LIB} ${MKL_THREAD_LIB} ${MKL_CORE_LIB} -lgomp)
+      REQUIRED
+      )
+  endif()
+  find_library(MKL_CORE_LIB mkl_core 
+    HINTS "${MKLROOT}/lib/intel64" 
+    "${MKLROOT}/lib" 
+    REQUIRED
+    )
+  if("${UNAME_S}" STREQUAL "Darwin")
+    target_link_libraries(regenie ${MKL_LP64_LIB} ${MKL_THREAD_LIB} ${MKL_CORE_LIB})
+  elseif(${BUILD_STATIC})
+    target_link_libraries(regenie "-Wl,--start-group" ${MKL_LP64_LIB} ${MKL_THREAD_LIB} ${MKL_CORE_LIB} "-Wl,--end-group" -lgomp)
+  else() # use dynamic libs
+    target_link_libraries(regenie "-Wl,--no-as-needed" ${MKL_LP64_LIB} ${MKL_THREAD_LIB} ${MKL_CORE_LIB} -lgomp)
   endif()
-elseif(EXISTS ${OPENBLAS_ROOT}) # OpenBLAS
-  add_definitions(-DWITH_OPENBLAS -DEIGEN_USE_BLAS -DEIGEN_USE_LAPACKE)
-  target_include_directories(regenie PRIVATE ${OPENBLAS_ROOT}/include/)
-  find_library(LAPACK_LIB lapack REQUIRED)
-  find_library(BLAS_LIB openblas HINTS "${OPENBLAS_ROOT}/lib/" REQUIRED)
-  target_link_libraries(regenie PRIVATE ${LAPACK_LIB} -llapacke ${BLAS_LIB})
+  message( STATUS "Will compile with Intel MKL library")
 endif()
 
 # cxxopts (header-only)
-target_include_directories(regenie PRIVATE ${EXTERN_LIBS_PATH}/cxxopts/include/)
+target_include_directories(regenie PUBLIC ${CMAKE_SOURCE_DIR}/external_libs/cxxopts/include/)
 
 # LBFGS (header-only)
-target_include_directories(regenie PRIVATE ${EXTERN_LIBS_PATH}/LBFGSpp/include/)
+target_include_directories(regenie PUBLIC ${CMAKE_SOURCE_DIR}/external_libs/LBFGSpp/include/)
 
 # Eigen (header-only)
-target_include_directories(regenie PRIVATE ${EXTERN_LIBS_PATH}/eigen-3.4.0/)
-
-# Boost IO
-if(${HAS_BOOST_IOSTREAM})
-  if("${UNAME_S}" STREQUAL "Darwin")
-    find_library(BOOST_LIB_IO libboost_iostreams libboost_iostreams.a REQUIRED)
-    target_link_libraries(regenie PRIVATE ${BOOST_LIB_IO})
-  elseif(${BUILD_STATIC})
-    find_library(BOOST_LIB_IO libboost_iostreams.a REQUIRED)
-    target_link_libraries(regenie PRIVATE ${BOOST_LIB_IO})
-  else()
-    target_link_libraries(regenie PRIVATE -lboost_iostreams)
-  endif()
-  add_definitions(-DHAS_BOOST_IOSTREAM)
-  message( STATUS "Will compile with Boost Iostreams library")
-endif()
+target_include_directories(regenie PUBLIC ${CMAKE_SOURCE_DIR}/external_libs/eigen-3.4.0/)
 
 # Other libraries
-find_library(ZLIB_LIBRARY libz.a z REQUIRED)
-find_library(M_LIB m REQUIRED)
-find_library(DL_LIB dl REQUIRED)
+find_library(ZLIB_LIBRARY z REQUIRED)
+find_library(M_LIB m REQUIRED) 
+find_library(DL_LIB dl REQUIRED) 
 if("${UNAME_S}" STREQUAL "Linux")
   set(GFORTRAN_LIBRARY "-lgfortran")
 elseif("${UNAME_S}" STREQUAL "Darwin")
   find_library(GFORTRAN_LIBRARY gfortran REQUIRED)
 endif()
-target_link_libraries(
-  regenie PRIVATE
-  ${ZLIB_LIBRARY} ${M_LIB} ${DL_LIB} ${PTHREAD_LIB}
-  ${GFORTRAN_LIBRARY}
-)
+target_link_libraries(regenie ${ZLIB_LIBRARY} ${M_LIB} ${DL_LIB} ${PTHREAD_LIB} ${GFORTRAN_LIBRARY})
 
-install(TARGETS regenie RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
+add_definitions(-DVERSION_NUMBER="${RG_VERSION}")
+install(TARGETS regenie RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} OPTIONAL)
 message( STATUS "REGENIE v" ${RG_VERSION})
 
-add_custom_target(full-clean
-  COMMAND cd "${MVTN_PATH}" && make clean
-  COMMAND cd "${QF_PATH}" && make clean
-  COMMAND cd "${QUAD_PATH}" && make clean
-  COMMAND cd "${PGEN_PATH}" && make clean
-  )
+write_basic_package_version_file(${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}-config-version.cmake COMPATIBILITY SameMajorVersion)
+install(FILES ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}-config-version.cmake DESTINATION share/${PROJECT_NAME})
+
+set(CPACK_PACKAGE_VERSION_MAJOR ${PROJECT_VERSION_MAJOR})
+set(CPACK_PACKAGE_VERSION_MINOR ${PROJECT_VERSION_MINOR})
+set(CPACK_PACKAGE_VERSION_PATCH ${PROJECT_VERSION_PATCH})
+include(CPack)
diff --git a/binary/regenie-3.6-h6578b86_0.tar.bz2 b/binary/regenie-3.6-h6578b86_0.tar.bz2
new file mode 100644
index 0000000..e49ffbe
Binary files /dev/null and b/binary/regenie-3.6-h6578b86_0.tar.bz2 differ
diff --git a/external_libs/mvtnorm/Makefile b/external_libs/mvtnorm/Makefile
index ac3d389..38edafa 100644
--- a/external_libs/mvtnorm/Makefile
+++ b/external_libs/mvtnorm/Makefile
@@ -1,4 +1,4 @@
-FLAG  =-O2 -DNDEBUG -fPIC
+FLAG  =-O3 -DNDEBUG -fPIC
 AR   ?= ar
 CXX  ?= g++
 CC   ?= gcc
diff --git a/external_libs/mvtnorm/mvtnorm.cpp b/external_libs/mvtnorm/mvtnorm.cpp
index 94a83b2..418b2f0 100644
--- a/external_libs/mvtnorm/mvtnorm.cpp
+++ b/external_libs/mvtnorm/mvtnorm.cpp
@@ -1,4 +1,4 @@
-
+#include <algorithm> 
 #include <stdlib.h>
 #include <stdio.h>
 #include "mvtnorm.h"
@@ -47,9 +47,9 @@ double pmvnorm_complement(int n,
     double* error)
 {
   int nu_ = 0;
-  int maxpts_ = maxpts;
-  double abseps_ = abseps;
-  double releps_ = 0;
+  int maxpts_ = std::max(maxpts, n * 1000); // Set maxpts_ to the maximum of maxpts and n * 1000
+  double abseps_ = std::min(abseps, 1.0 / (n * 1000)); // Set abseps_ to the minimum of abseps and 1.0 / (n * 1000)
+  double releps_ = 0.0;
 
   double* upper = new double[n];
   int* infin = new int[n];
@@ -63,7 +63,7 @@ double pmvnorm_complement(int n,
 
   // values to return
   double value_ = 0.0;
-  int inform_ = 0.0;
+  int inform_ = 0;
 
   double ret = pmvnorm(&n, &nu_, 
       bound, upper, infin, cmat, delta, 
diff --git a/external_libs/pgenlib/Makefile b/external_libs/pgenlib/Makefile
index 262d920..5640d61 100644
--- a/external_libs/pgenlib/Makefile
+++ b/external_libs/pgenlib/Makefile
@@ -3,7 +3,7 @@
 #
 AR         ?= ar
 CXX        ?= g++
-CXXFLAGS    = -O3 -Wall -std=c++11
+CXXFLAGS    = -O3 -Wall -std=c++14
 CFLAGS      = 
 
 UNAME_S := $(shell uname -s)
diff --git a/external_libs/qf/Makefile b/external_libs/qf/Makefile
index 3d0341a..351dd5d 100644
--- a/external_libs/qf/Makefile
+++ b/external_libs/qf/Makefile
@@ -1,6 +1,6 @@
 AR       ?= ar
 CXX      ?= g++
-CXXFLAGS  = -O2 -DNDEBUG -fPIC
+CXXFLAGS  = -O3 -DNDEBUG -fPIC
 
 UNAME_S := $(shell uname -s)
 ifeq ($(UNAME_S),Darwin)
diff --git a/external_libs/quadpack/Makefile b/external_libs/quadpack/Makefile
index e160de3..03c6e5a 100644
--- a/external_libs/quadpack/Makefile
+++ b/external_libs/quadpack/Makefile
@@ -1,4 +1,4 @@
-FLAG=-O2 -DNDEBUG -fPIC -std=legacy
+FLAG=-O3 -DNDEBUG -fPIC -std=legacy
 AR   ?= ar
 FC   ?= gfortran
 
diff --git a/external_libs/remeta/Makefile b/external_libs/remeta/Makefile
index 195706d..684540d 100644
--- a/external_libs/remeta/Makefile
+++ b/external_libs/remeta/Makefile
@@ -25,4 +25,4 @@ remeta.a: ${OBJECTS}
 	${CXX} ${CXXFLAGS} -o $@ -c $< -I${INC}
 
 clean:
-	rm -f *.o *.a
\ No newline at end of file
+	rm -f *.o *.a
diff --git a/src/Data.cpp b/src/Data.cpp
index 71f9fb3..95d36c4 100755
--- a/src/Data.cpp
+++ b/src/Data.cpp
@@ -977,6 +977,7 @@ void Data::output() {
   if(params.write_null_firth){
     out_firth_list = files.out_file + "_firth.list";
     outf.openForWrite(out_firth_list, sout);
+    m_ests.blups.resize(params.n_samples, params.n_pheno);
   }
 
   for(int ph = 0; ph < params.n_pheno; ++ph ) {
@@ -1872,25 +1873,23 @@ void Data::write_predictions(int const& ph){
   if(params.write_null_firth){ // store null estimates for Firth
 
     bool has_converged = true;
-    double dev, tstat;
-    ArrayXd se, etavec, pivec;
     IOFormat Fmt(StreamPrecision, DontAlignCols, " ", "\n", "", "","","");
 
     out = files.out_file + "_" + to_string(ph+1) + ".firth" + (params.gzOut ? ".gz" : "");
     sout << "writing null approximate Firth estimates..." << flush;
     ofile.openForWrite(out, sout);
 
-    ArrayXd bhat = ArrayXd::Zero(params.ncov);
     MapArXd Y (pheno_data.phenotypes_raw.col(ph).data(), pheno_data.phenotypes_raw.rows());
     MapArXb mask (pheno_data.masked_indivs.col(ph).data(), pheno_data.masked_indivs.rows());
+    // not quite matching with step 2 due to offset not being used in logreg
+    ArrayXd bhat = m_ests.bhat_start.col(ph).array();
 
     for(int chr = 0; chr < params.nChrom; chr++) {
-      // fit null approximate Firth 
+      // fit null approximate Firth
       // use warm starts from previous chromosomes
-      if(!fit_firth(ph, Y, pheno_data.new_cov, pred.col(chr).array(), mask, pivec, etavec, bhat, se, params.ncov, dev, false, tstat, params.maxstep_null, params.niter_max_firth_null, 50 * params.numtol, &params)){
-        has_converged = false;
-        break;
-      }
+      m_ests.blups.col(ph) = pred.col(chr);
+      has_converged = fit_approx_firth_null(chr, ph, &pheno_data, &m_ests, bhat, &params);
+      if(!has_converged) break;
       ofile << chr + 1 << " " << bhat.matrix().transpose().format(Fmt) << endl;
     }
 
@@ -1902,7 +1901,6 @@ void Data::write_predictions(int const& ph){
 
   }
 
-
   if(params.print_prs){
 
     out = files.out_file + "_" + to_string(ph+1) + ".prs" + (params.gzOut ? ".gz" : "");
diff --git a/src/NNLS.cpp b/src/NNLS.cpp
index 43d9d7b..98e4ec0 100644
--- a/src/NNLS.cpp
+++ b/src/NNLS.cpp
@@ -30,6 +30,33 @@
 using namespace Eigen;
 using namespace std;
 
+/***************************************
+ * NLLS: the main function: 
+ * - model fitting
+ * - update V matrix & compute weigts
+ * - compute p-values using chi2bar 
+ * - return min(pval_pos_nnls, pval_neg_nnls)
+***************************************/
+
+Eigen::MatrixXd _npd(const Eigen::MatrixXd& X, double eps = 1e-8)
+{
+  // method 1: diag(X) = diag(X) + eps
+  /* V = 0.5 * (V + V.transpose()); // force it symmetric */
+  /* double eps = 1e-4; // to be a function argument */
+  /* V.diagonal().array() += eps; // force positive-definite */
+  
+  // method 2: EVD (negative eigenvalues -> 0) + diag(X) = diag(X) + eps
+  MatrixXd Y = 0.5 * (X + X.transpose());
+  SelfAdjointEigenSolver<MatrixXd> solver(Y);
+  VectorXd D = solver.eigenvalues();
+  MatrixXd V = solver.eigenvectors();
+  VectorXd Dplus = D.cwiseMax(0.0);
+  MatrixXd Z = V * Dplus.asDiagonal() * V.transpose();
+  Z.diagonal().array() += eps;
+
+  return(Z);
+}
+
 /****************************************************
  * Compute weights for the NNLS test
  * ic.weights function in the R package ic.infer
@@ -38,7 +65,8 @@ using namespace std;
 Eigen::MatrixXd _inverse(const Eigen::MatrixXd& V)
 {
   int n = V.rows();
-  MatrixXd Vinv = V.llt().solve(MatrixXd::Identity(n, n));
+  MatrixXd Vpd = _npd(V);
+  MatrixXd Vinv = Vpd.llt().solve(MatrixXd::Identity(n, n));
   /* MatrixXd Vinv = V.inverse(); */
   return(Vinv);
 }
@@ -240,6 +268,8 @@ double jburden_pnorm(const Eigen::MatrixXd& A,
   double* cmat = new double[nc];
   double error, ret; 
 
+  Eigen::MatrixXd Apd = _npd(A);  
+  
   // fill n bounds with 0
   for(i = 0; i < n; ++i) {
     bound[i] = 0.0;
@@ -250,7 +280,7 @@ double jburden_pnorm(const Eigen::MatrixXd& A,
   /* Eigen::MatrixXd C = wts_cov2cor(A); */
   vector<double> sd(n);
   for(int i = 0; i < n; ++i) {
-    sd[i] = sqrt(A(i, i));
+    sd[i] = sqrt(Apd(i, i));
   }
   
 
@@ -260,7 +290,7 @@ double jburden_pnorm(const Eigen::MatrixXd& A,
   k = 0; // counter for filled entries in cmat
   for(i = 0; i < n; ++i) {
     for(j = 0; j < i; ++j) {
-      cmat[k] = A(i, j) / (sd[i]*sd[j]);
+      cmat[k] = Apd(i, j) / (sd[i]*sd[j]);
       k += 1;
       /* file << cmat[k] << "\t"; */
     }
@@ -1049,33 +1079,6 @@ int jburden_wts_adapt(const Eigen::MatrixXd& V, Eigen::VectorXd& wts_out, std::m
   return(0);
 }
 
-/***************************************
- * NLLS: the main function: 
- * - model fitting
- * - update V matrix & compute weigts
- * - compute p-values using chi2bar 
- * - return min(pval_pos_nnls, pval_neg_nnls)
-***************************************/
-
-Eigen::MatrixXd _npd(const Eigen::MatrixXd& X, double eps = 1e-6)
-{
-  // method 1: diag(X) = diag(X) + eps
-  /* V = 0.5 * (V + V.transpose()); // force it symmetric */
-  /* double eps = 1e-4; // to be a function argument */
-  /* V.diagonal().array() += eps; // force positive-definite */
-  
-  // method 2: EVD (negative eigenvalues -> 0) + diag(X) = diag(X) + eps
-  MatrixXd Y = 0.5 * (X + X.transpose());
-  SelfAdjointEigenSolver<MatrixXd> solver(Y);
-  VectorXd D = solver.eigenvalues();
-  MatrixXd V = solver.eigenvectors();
-  VectorXd Dplus = D.cwiseMax(0.0);
-  MatrixXd Z = V * Dplus.asDiagonal() * V.transpose();
-  Z.diagonal().array() += eps;
-
-  return(Z);
-}
-
 // main function for the NNLS test
 double jburden_test(const Eigen::VectorXd &y, const Eigen::MatrixXd& X, std::mt19937_64& gen,
   int df, double tol, int n_approx, bool strict, int verbose)
diff --git a/src/NNLS.hpp b/src/NNLS.hpp
index 1ab40be..6fcfe63 100644
--- a/src/NNLS.hpp
+++ b/src/NNLS.hpp
@@ -66,7 +66,7 @@ int jburden_wts_adapt(const Eigen::MatrixXd& V, Eigen::VectorXd& wts_out, std::m
 
 // compute CDF for MVN
 double jburden_pnorm(const Eigen::MatrixXd& A, 
-  int maxpts = 25000, double abseps = 1e-3, int verbose = 0);
+  int maxpts = 50000, double abseps = 1e-3, int verbose = 0);
 // the active set algorithm for fitting NNLS
 int jburden_fit_nnls(const Eigen::VectorXd &y, const Eigen::MatrixXd& X, 
   Eigen::VectorXd& bhat_out, vector<bool>& selected_out,
diff --git a/src/Step1_Models.cpp b/src/Step1_Models.cpp
index b72daa8..a5c9a6b 100644
--- a/src/Step1_Models.cpp
+++ b/src/Step1_Models.cpp
@@ -59,7 +59,7 @@ void fit_null_logistic(bool const& silent, const int& chrom, struct param* param
   auto t1 = std::chrono::high_resolution_clock::now();
   ArrayXd betaold, etavec, pivec, loco_offset, wvec;
   MatrixXd XtW;
-  if(params->w_interaction || params->firth || (params->use_SPA && params->vc_test)) m_ests->bhat_start.resize(pheno_data->new_cov.cols(), params->n_pheno);
+  if(params->w_interaction || params->firth || (params->use_SPA && params->vc_test) || params->write_null_firth) m_ests->bhat_start.resize(pheno_data->new_cov.cols(), params->n_pheno);
   if(params->w_interaction) m_ests->offset_nullreg.resize(pheno_data->new_cov.rows(), params->n_pheno);
   betaold = ArrayXd::Zero(pheno_data->new_cov.cols());
 
@@ -132,7 +132,10 @@ void fit_null_logistic(bool const& silent, const int& chrom, struct param* param
       getBasis(m_ests->X_Gamma[i], params);
       if(params->w_interaction || params->firth || (params->use_SPA && params->vc_test)) m_ests->bhat_start.col(i) = betaold.matrix();
       if(params->w_interaction) m_ests->offset_nullreg.col(i) = etavec;
-    } else m_ests->offset_nullreg.col(i) = etavec;
+    } else {
+      m_ests->offset_nullreg.col(i) = etavec;
+      if(params->write_null_firth) m_ests->bhat_start.col(i) = betaold.matrix();
+    }
 
     /*
      Files fstar;
